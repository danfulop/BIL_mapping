library(lme4)
library(ggplot2)
library(plyr)
library(coefplot2)
library(fdrtool)
library(parallel)
library(doParallel)
library(foreach)

# Load Leaf complexity dataset
setwd("/Users/Dani/UCD/BILs/leaf_traits/")
# load data tables
comp <- read.delim("BIL.complexity.all.2011.txt")
head(comp)  
summary(comp)
nlevels(comp$genotype) # 545
comp$block <- as.factor(substr(comp$plant,1,1)) # capture block information from the plant ID
head(comp$genotype)
levels(comp$genotype) # zeroes need to be added to the BIL#s for BILs whose number is less than 100
comp.rn <- comp
comp.rn$genotype <- as.character(comp.rn$genotype)
# ADD zeroes to too short BIL IDs
len6idx <- which(nchar(comp.rn$genotype[]) == 6) # length == 6 BIL names indices
len5idx <- which(nchar(comp.rn$genotype[]) == 5) # length == 5 BIL names indices
comp.rn$genotype[len6idx] <- paste0("BIL_0", substr(comp.rn$genotype[len6idx], 5, 6))
comp.rn$genotype[len5idx] <- paste0("BIL_00", substr(comp.rn$genotype[len5idx], 5, 5))
comp.rn$genotype
as.factor(comp.rn$genotype)

load("~/UCD/BILs/bil.reassign.Rdata") # Load bil.reassign, which is generated by bin_classif.R script, to reassign BIL IDs to account for duplicate BILs
comp.rn <- merge(comp.rn, bil.reassign, by.x="genotype", by.y="BIL") # merge by original BIL# assignment
head(comp.rn, 50)
comp.rn$genotype <- as.factor(comp.rn$genotype)
comp.rn$FinBIL <- as.factor(comp.rn$FinBIL)
levels(comp.rn$FinBIL)
comp.rn$FinBIL<- relevel(comp.rn$FinBIL, "M82")
comp.rn <- droplevels(comp.rn)

# Function to calculate model-fitted means and generate "swooshPlots"
fitMean <- function(x, y, labV, i, randform) {  # Include as input column index of response values, i.e. y
  resp <- names(x)[y] # assign the column name of the 'y' index
  formula <- as.formula( paste0( get("resp"), " ~ FinBIL + (1|block) + ", get("randform") ) )
  fit <- lmer(formula, data=x, REML=TRUE)
  tab <- as.data.frame(coeftab(fit)) # save fixed effect table
  tab$p.z <- 2 * pnorm(abs(data.frame(coef(summary(fit)))$t.value), lower.tail=FALSE) # normal approximation to p-values, which is very valid because the number of groups is very large i.e. >> ~40-50
  rownames(tab)[1] <- "M82" # relabel intercept as M82
  tab$geno <- rownames(tab) # copy BIL IDs
  tab$geno[2:nrow(tab)] <- substr(tab$geno[2:nrow(tab)],7,13) # Trim the coefficient names to get proper genotype/line names
  names(tab)[2] <- 'StdErr'; names(tab)[7] <- 'p.value'; names(tab)[3] <- 'lowerCI'; names(tab)[6] <- 'upperCI' # rename pertinent columns
  tab$p.value[tab$geno=="M82"] <- 1 # assign pval=1 for M82, b/c it's the intercept and thus the reference value for others' p-values
  tab[2:nrow(tab),c(1,3:6)] <- tab[2:nrow(tab),c(1,3:6)] + tab[1,1] # add the intercept to the BIL's estimates quantile estimates of the genotype coefficients
  tab$lowerStdDev <- tab$Estimate - tab$StdErr # estimate - std err -- calculate lower error bar limit
  tab$upperStdDev <- tab$Estimate + tab$StdErr # estimate + std err -- calculate upper error bar limit
  tab <- tab[with(tab, order(Estimate)), ] # reorder estimates table by the estimates' values
  tab$geno <- factor(tab$geno, levels=tab$geno)
  fdr <- fdrtool(tab$p.value, statistic="pvalue", plot=FALSE) # adaptive FDR multiple testing correction
  tab$q.value <- fdr$qval
  tab$Significance[tab$q.value > 0.05] <- "non-significant"
  tab$Significance[tab$q.value < 0.05 & tab$q.value > 0.01] <- "q.value_<_0.05"
  tab$Significance[tab$q.value < 0.01 & tab$q.value > 0.001] <- "q.value_<_0.01"
  tab$Significance[tab$q.value < 0.001] <- "q.value_<_0.001"
  tab$Significance[tab$geno=="M82"] <- "M82"
  tab$Significance <- factor(tab$Significance, levels=c("non-significant", "q.value_<_0.05", "q.value_<_0.01", "q.value_<_0.001", "M82"),
                             labels=c("non-significant", "q-value < 0.05", "q-value < 0.01", "q-value < 0.001", "M82") )
  swooshPlot <- ggplot(tab, aes(y=Estimate, x=geno, ymin=lowerStdDev, ymax=upperStdDev, color=Significance)) + 
    geom_linerange(aes(ymin=lowerCI, ymax=upperCI), alpha=0.5) + geom_pointrange() + theme_bw(16) + 
    theme(axis.text.x = element_text(size=3.5, angle=50, vjust=1, hjust=1)) + labs(x="Genotype", y=labV[i]) +
    scale_color_manual(values = c("#de77ae", "#8e0152", "#276419", "#7fbc41", "#4c4c4c") ) # custom color-blind friendly color palette
  ggsave(filename=paste0(names(x)[y], ".pdf"), swooshPlot, width=30, height=15) # use trait column labels to name the preliminary plots
  resultsList <- list(fittedMeans = tab, plot = swooshPlot)
  resultsList
}

#---- Complexity data
# Initialize lists in which to save the ggplot objects and the data.frames with model-fitted means 
comp.list <- vector("list", length=4)
# Vector of Y-axis labels for complexity data => use this for function input "labV" or label vector
comp.y.labs <- c("Leaf complexity, primary (leaflet counts)", "Leaf complexity, intercalary (leaflet counts)",
                 "Leaf complexity, secondary (leaflet counts)", "Leaf complexity, all (leaflet counts)" )

# Iterate through complexity traits w/ a foreach loop
registerDoParallel(cores=4) # register parallel backend
mcoptions <- list(preschedule=TRUE, set.seed=FALSE) # multi-core options
comp.list <- foreach(i=1:4, .options.multicore=mcoptions) %dopar% { # run loop
  y = i + 4
  comp.list[i] <- fitMean(x=comp.rn, y=y, labV=comp.y.labs, i=i, randform="(1|plant)" )
}
names(comp.list) <- names(comp.rn)[5:8] # name the list elements by their original trait names
save(comp.list, file="comp.list.Rdata") # Save results list

#---- Labels for genotype and field info.
# subset comp.rn and run unique() to make a table with just the genotype and field spatial info. to merge onto the other datasets
labels <- comp.rn[c(2,9,1,10)]
labels <- unique(labels)

#---- Circularity and related data from ImageJ
circ <- read.delim("BIL.circAR.all.2011.txt")
circ <- merge(circ, labels, by="plant")
circ <- droplevels(circ)
names(circ)[3] <- "leaflet.type"
circ.y.labs <- c("Area (Âµm^2)", "Circularity", "Aspect Ratio", "Roundness", "Solidity") # y-axis labels
# run loop
circ.list <- vector("list", length=5)
registerDoParallel(cores=4) # register parallel backend
mcoptions <- list(preschedule=TRUE, set.seed=FALSE) # multi-core options
circ.list <- foreach(i=1:5, .options.multicore=mcoptions) %dopar% { # run loop
  y = i + 4
  circ.list[i] <- fitMean(x=circ, y=y, labV=circ.y.labs, i=i, randform="(1 | plant / leaflet.type)" )
}
names(circ.list) <- names(circ)[5:9] # name the list elements by their original trait names
save(circ.list, file="circ.list.Rdata") # Save results list

#---- Symmetric PCA data from Elliptical Fourier shape analysis
sym <- read.delim("BIL_Spcascores.txt")
sym <- merge(sym, labels, by="plant")
sym <- droplevels(sym)
names(sym)[4] <- "leaflet.type"
sym.y.labs <- paste0("Symmetric EFD ", names(sym)[6:14])
# run loop
sym.list <- vector("list", length=9)
registerDoParallel(cores=4) # register parallel backend
mcoptions <- list(preschedule=TRUE, set.seed=FALSE) # multi-core options
sym.list <- foreach(i=1:9, .options.multicore=mcoptions) %dopar% { # run loop
  y = i + 5
  sym.list[i] <- fitMean(x=sym, y=y, labV=sym.y.labs, i=i, randform="(1 | plant / leaflet.type)" )
}
names(sym.list) <- names(sym)[6:14] # name the list elements by their original trait names
save(sym.list, file="sym.list.Rdata") # Save results list

#---- Asymmetric PCA data from Elliptical Fourier shape analysis
asym <- read.delim("BIL_ASpcascores.txt")
asym <- merge(asym, labels, by="plant")
asym <- droplevels(asym)
names(asym)[4] <- "leaflet.type"
asym <- asym[asym$leaflet.type != "t",] # remove terminal leaflets, because they shouldn't be included in asymmetric shape analysis
asym <- droplevels(asym) # drop levels again to remove terminal leaflet type level
asym[6:12] <- abs(asym[6:12]) # take the absolute value of the PCs so that the asymmetry traits are enantiomer-independent (i.e. left and right lateral leaflets are treated equally)
asym.y.labs <- paste0("Asymmetric EFD ", names(asym)[6:12])
# run loop
asym.list <- vector("list", length=7)
registerDoParallel(cores=4) # register parallel backend
mcoptions <- list(preschedule=TRUE, set.seed=FALSE) # multi-core options
asym.list <- foreach(i=1:7, .options.multicore=mcoptions) %dopar% { # run loop
  y = i + 5
  asym.list[i] <- fitMean(x=asym, y=y, labV=asym.y.labs, i=i, randform="(1 | plant)" )
}
names(asym.list) <- names(asym)[6:12] # name the list elements by their original trait names
save(asym.list, file="asym.list.Rdata") # Save results list

#---- Calculate predicted response value excluding random effects to use as data for SparseNet 

#---- Prediction function:
predResp <- function(x, y, randform) {  # Include as input column index of response values, i.e. y
  resp <- names(x)[y] # assign the column name of the 'y' index
  formula <- as.formula( paste0( get("resp"), " ~ (1|block) + ", get("randform") ) )
  fit <- lmer(formula, data=x, REML=TRUE)
  newdata <- with(x, expand.grid(plant=unique(plant)))
  pred <- predict(fit, newdata, re.form=~(1|plant), type="response", allow.new.levels=TRUE)
  predDat <- as.data.frame(cbind(plant=newdata, prediction=pred)) # join the plant labels and predicted responses in a data frame
  labs <- x[c('genotype', 'FinBIL', 'plant')] # subset data frame to only have genotype info. and plant ID
  labs <- unique(labs) # keep only one row per plant
  predDat <- merge(labs, predDat, by="plant")
  fit.df <- fit@frame # get the LMM-object's response and factor data frame
  fit.df$resid <- residuals(fit, type="response", scaled=FALSE) # calculate residuals
  fit.df <- fit.df[3:4]  # subset to only keep plant ID and residuals
  mean.resid <- ddply(fit.df, .(plant), function(x) {  # calculate mean residuals
    mean.resid <- mean(x$resid)
    data.frame(mean.resid=mean.resid)
  })
  predDat <- merge(predDat, mean.resid)  # merge mean residuals onto predictions
  predDat$predPlusResid <- predDat$prediction + predDat$mean.resid
  predDat
}

#---- Complexity data
comp.pred <- vector("list", length=4)
# Iterate through complexity traits w/ a foreach loop
registerDoParallel(cores=4) # register parallel backend
mcoptions <- list(preschedule=TRUE, set.seed=FALSE) # multi-core options
comp.pred <- foreach(i=1:4, .options.multicore=mcoptions) %dopar% { # run loop
  y = i + 4
  comp.pred[i] <- predResp(x=comp.rn, y=y, randform="(1|plant)" )
}
names(comp.pred) <- names(comp.rn)[5:8] # name the list elements by their original trait names
save(comp.pred, file="comp.pred.Rdata") # Save prediction data.frames' list

#---- Circ. data
circ.pred <- vector("list", length=5)
registerDoParallel(cores=4) # register parallel backend
circ.pred <- foreach(i=1:5, .options.multicore=mcoptions) %dopar% { # run loop
  y = i + 4
  circ.pred[i] <- predResp(x=circ, y=y, randform="(1 | plant / leaflet.type)" )
}
names(circ.pred) <- names(circ)[5:9] # name the pred elements by their original trait names
save(circ.pred, file="circ.pred.Rdata") # Save prediction data.frames' list

#---- Symmetric EFD-PCs
sym.pred <- vector("list", length=9)
registerDoParallel(cores=4) # register parallel backend
sym.pred <- foreach(i=1:9, .options.multicore=mcoptions) %dopar% { # run loop
  y = i + 5
  sym.pred[i] <- predResp(x=sym, y=y, randform="(1 | plant / leaflet.type)" )
}
names(sym.pred) <- names(sym)[6:14] # name the pred elements by their original trait names
save(sym.pred, file="sym.pred.Rdata") # Save prediction data.frames' list

#---- Asymmetric EFD-PCs
asym.pred <- vector("list", length=7)
registerDoParallel(cores=4) # register parallel backend
asym.pred <- foreach(i=1:7, .options.multicore=mcoptions) %dopar% { # run loop
  y = i + 5
  asym.pred[i] <- predResp(x=asym, y=y, randform="(1 | plant)" )
}
names(asym.pred) <- names(asym)[6:12] # name the pred elements by their original trait names
save(asym.pred, file="asym.pred.Rdata") # Save prediction data.frames' list
