library(lme4)
library(ggplot2)
library(coefplot2)
library(fdrtool)
library(parallel)
library(doParallel)
library(foreach)

# Load Leaf complexity dataset
setwd("/Users/Dani/UCD/BILs/leaf_traits/")
# load data tables
comp <- read.delim("BIL.complexity.all.2011.txt")
head(comp)  
summary(comp)
nlevels(comp$genotype) # 545
comp$block <- as.factor(substr(comp$plant,1,1)) # capture block information from the plant ID
head(comp$genotype)
levels(comp$genotype) # zeroes need to be added to the BIL#s for BILs whose number is less than 100
comp.rn <- comp
comp.rn$genotype <- as.character(comp.rn$genotype)
# ADD zeroes to too short BIL IDs
len6idx <- which(nchar(comp.rn$genotype[]) == 6) # length == 6 BIL names indices
len5idx <- which(nchar(comp.rn$genotype[]) == 5) # length == 5 BIL names indices
comp.rn$genotype[len6idx] <- paste0("BIL_0", substr(comp.rn$genotype[len6idx], 5, 6))
comp.rn$genotype[len5idx] <- paste0("BIL_00", substr(comp.rn$genotype[len5idx], 5, 5))
comp.rn$genotype
as.factor(comp.rn$genotype)

load("~/UCD/BILs/bil.reassign.Rdata") # Load bil.reassign, which is generated by bin_classif.R script, to reassign BIL IDs to account for duplicate BILs
comp.rn <- merge(comp.rn, bil.reassign, by.x="genotype", by.y="BIL") # merge by original BIL# assignment
head(comp.rn, 50)
comp.rn$genotype <- as.factor(comp.rn$genotype)
comp.rn$FinBIL <- as.factor(comp.rn$FinBIL)
levels(comp.rn$FinBIL)
comp.rn$FinBIL<- relevel(comp.rn$FinBIL, "M82")

# Function to calculate model-fitted means and generate "swooshPlots"
fitMean <- function(x, y, labV, i, randform) {  # Include as input column index of response values, i.e. y
  resp <- names(x)[y] # assign the column name of the 'y' index
  formula <- as.formula( paste0( get("resp"), " ~ FinBIL + (1|block) + ", get("randform") ) )
  fit <- lmer(formula, data=x, REML=TRUE)
  tab <- as.data.frame(coeftab(fit)) # save fixed effect table
  tab$p.z <- 2 * pnorm(abs(data.frame(coef(summary(fit)))$t.value), lower.tail=FALSE) # normal approximation to p-values, which is very valid because the number of groups is very large i.e. >> ~40-50
  pvals <- 2 * pt(abs(data.frame(coef(summary(fit)))$t.value), df=degfree, lower.tail=FALSE)
  rownames(tab)[1] <- "M82" # relabel intercept as M82
  tab$geno <- rownames(tab) # copy BIL IDs
  tab$geno[2:nrow(tab)] <- substr(tab$geno[2:nrow(tab)],7,13) # Trim the coefficient names to get proper genotype/line names
  names(tab)[2] <- 'StdErr'; names(tab)[7] <- 'p.value'; names(tab)[3] <- 'lowerCI'; names(tab)[6] <- 'upperCI' # rename pertinent columns
  tab$p.value[tab$geno=="M82"] <- 1 # assign pval=1 for M82, b/c it's the intercept and thus the reference value for others' p-values
  tab[2:nrow(tab),c(1,3:6)] <- tab[2:nrow(tab),c(1,3:6)] + tab[1,1] # add the intercept to the BIL's estimates quantile estimates of the genotype coefficients
  tab$lowerStdDev <- tab$Estimate - tab$StdErr # estimate - std err -- calculate lower error bar limit
  tab$upperStdDev <- tab$Estimate + tab$StdErr # estimate + std err -- calculate upper error bar limit
  tab <- tab[with(tab, order(Estimate)), ]
  tab$geno <- factor(tab$geno, levels=tab$geno)
  fdr <- fdrtool(tab$p.value, statistic="pvalue", plot=TRUE)
  tab$q.value <- fdr$qval
  tab$Significance[tab$q.value > 0.05] <- "non-significant"
  tab$Significance[tab$q.value < 0.05 & tab$q.value > 0.01] <- "q.value_<_0.05"
  tab$Significance[tab$q.value < 0.01 & tab$q.value > 0.001] <- "q.value_<_0.01"
  tab$Significance[tab$q.value < 0.001] <- "q.value_<_0.001"
  tab$Significance[tab$geno=="M82"] <- "M82"
  tab$Significance <- factor(tab$Significance, levels=c("non-significant", "q.value_<_0.05", "q.value_<_0.01", "q.value_<_0.001", "M82"),
                             labels=c("non-significant", "q.value < 0.05", "q.value < 0.01", "q.value < 0.001", "M82") )
  swooshPlot <- ggplot(tab, aes(y=Estimate, x=geno, ymin=lowerStdDev, ymax=upperStdDev, color=Significance)) + 
    geom_linerange(aes(ymin=lowerCI, ymax=upperCI), alpha=0.5) + geom_pointrange() + theme_bw(16) + 
    theme(axis.text.x = element_text(size=3.5, angle=50, vjust=1, hjust=1)) + labs(x="Genotype", y=labV[i]) +
    scale_color_manual(values = c("#de77ae", "#8e0152", "#276419", "#7fbc41", "#4c4c4c") ) # custom color-blind friendly color palette
  ggsave(filename=paste0(names(x)[y], ".pdf"), swooshPlot, width=30, height=15) # use trait column labels to name the preliminary plots
  resultsList <- list(fittedMeans = tab, plot = swooshPlot)
  resultsList
}

# Initialize lists in which to save the ggplot objects and the data.frames with model-fitted means 
comp.list <- vector("list", length=4)
# Vector of Y-axis labels for complexity data => use this for function input "labV" or label vector
comp.y.labs <- c("Leaf complexity, primary (leaflet counts)", "Leaf complexity, intercalary (leaflet counts)",
                 "Leaf complexity, secondary (leaflet counts)", "Leaf complexity, all (leaflet counts)" )

# Iterate through complexity traits w/ a foreach loop
registerDoParallel(cores=4) # register parallel backend
mcoptions <- list(preschedule=TRUE, set.seed=FALSE) # multi-core options
nofun <- function(a,b) NULL # dummy function to prevent foreach() from joining objects
foreach(i=1:4, .options.multicore=mcoptions, .combine='nofun') %dopar% { # run loop
  y = i + 4
  comp.list[i] <- fitMean(x=comp.rn, y=y, labV=comp.y.labs, i=i, randform="(1|plant)" )
}
names(comp.list) <- names(comp.rn)[5:8] # name the list elements by their original trait names
save(comp.list, file="comp.list.Rdata") # Save results list

#----
# subset comp.rn and run unique() to make a table with just the genotype and field spatial info. to merge onto the other datasets
labels <- comp.rn[c(2,9,1,10)]
labels <- unique(labels)
#----
circ <- read.delim("BIL.circAR.all.2011.txt")
circ <- merge(circ, labels, by="plant")
circ <- droplevels(circ)
names(circ)[3] <- "leaflet.type"
circ.y.labs <- c("Area (Âµm^2)", "Circularity", "Aspect Ratio", "Roundness", "Solidity") # y-axis labels
# run loop
circ.list <- vector("list", length=5)
registerDoParallel(cores=4) # register parallel backend
mcoptions <- list(preschedule=TRUE, set.seed=FALSE) # multi-core options
foreach(i=1:5, .options.multicore=mcoptions, .combine='nofun', .verbose=TRUE) %dopar% { # run loop
  y = i + 4
  circ.list[i] <- fitMean(x=circ, y=y, labV=circ.y.labs, i=i, randform="(1 | plant / leaflet.type)" )
}
names(circ.list) <- names(circ)[5:9] # name the list elements by their original trait names
save(circ.list, file="circ.list.Rdata") # Save results list


#----
predResp




# Convert the model-fitted mean estimation below into a function to reuse for all traits (w/ the same expt. design)
# The same goes for predicted responses excluding random effects, i.e. convert to a function
#     The prediction function will need 2 variants, i.e. a 2nd one where the model is different (b/c of leaflets, etc) and the pseudo-replicates are averaged


# ** should I mess w/ testing each random effect term??  ...and only keeping the significant ones
#----
# form_noPlant <- as.formula( paste0( get("resp"), " ~ FinBIL + (1|block)" ) )
# fit_noPlant <- lmer(form_noPlant, data=x, REML=TRUE)
# 
# form_noBlock <- as.formula( paste0( get("resp"), " ~ FinBIL + (1|plant)" ) )
# fit_noBlock <- lmer(form_noBlock, data=x, REML=TRUE)
# 
# anova(fit, fit_noPlant)
# 
# anova(fit, fit_noBlock)
#----
