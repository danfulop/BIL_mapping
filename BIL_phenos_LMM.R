library(lme4)
library(ggplot2)
library(coefplot2)
library(pbkrtest)
library(fdrtool)
library(parallel)
library(foreach)

# Load Leaf complexity dataset
setwd("/Users/Dani/UCD/BILs/leaf_traits/")
# load data tables
comp <- read.delim("BIL.complexity.all.2011.txt")
head(comp)  
summary(comp)
nlevels(comp$genotype) # 545
comp$block <- as.factor(substr(comp$plant,1,1)) # capture block information from the plant ID
head(comp$genotype)
levels(comp$genotype) # ** zeroes need to be added to the BIL#s for BILs less than 100
comp.rn <- comp
comp.rn$genotype <- as.character(comp.rn$genotype)
# ADD zeroes to too short BIL IDs
len6idx <- which(nchar(comp.rn$genotype[]) == 6) # length == 6 BIL names indices
len5idx <- which(nchar(comp.rn$genotype[]) == 5) # length == 5 BIL names indices
comp.rn$genotype[len6idx] <- paste0("BIL_0", substr(comp.rn$genotype[len6idx], 5, 6))
comp.rn$genotype[len5idx] <- paste0("BIL_00", substr(comp.rn$genotype[len5idx], 5, 5))
comp.rn$genotype
as.factor(comp.rn$genotype)

load("~/UCD/BILs/bil.reassign.Rdata") ##** Load bil.reassign, which is generated by bin_classif.R script, to reassign BIL IDs to account for duplicate BILs
comp.rn <- merge(comp.rn, bil.reassign, by.x="genotype", by.y="BIL") # merge by original BIL# assignment
head(comp.rn, 50)
comp.rn$genotype <- as.factor(comp.rn$genotype)
comp.rn$FinBIL <- as.factor(comp.rn$FinBIL)
levels(comp.rn$FinBIL)
comp.rn$FinBIL<- relevel(comp.rn$FinBIL, "M82")

# Function to calculate model-fitted means and generate "swooshPlots" for complexity data (i.e. not pseudo-replicated at the leaflet level)
fitMean <- function(x, y) {  # Include as input column index of response values, i.e. y
  resp <- names(x)[y] # assign the column name of the 'y' index
  formula <- as.formula( paste0( get("resp"), " ~ FinBIL + (1|block) + (1|plant)" ) )
  fit <- lmer(formula, data=x, REML=TRUE)
  degfree <- get_ddf_Lb(fit, fixef(fit)) # get Kenward-Roger approximate degrees of freedom
  tab <- as.data.frame( coeftab(fit, df=degfree, p.val=TRUE) ) # save fixed effect table
  rownames(tab)[1] <- "M82" # relabel intercept as M82
  tab$geno <- rownames(tab) # copy BIL IDs
  tab$geno[2:nrow(tab)] <- substr(tab$geno[2:nrow(tab)],7,13)
  names(tab)[2] <- 'StdErr'
  names(tab)[7] <- 'p.value'
  names(tab)[3] <- 'lowerCI'
  names(tab)[6] <- 'upperCI'
  tab$p.value[tab$geno=="M82"] <- 1 # assign pval=1 for M82, b/c it's the intercept and thus the reference value for others' p-values
  tab[2:nrow(tab),c(1,3:6)] <- tab[2:nrow(tab),c(1,3:6)] + tab[1,1] # add the intercept to the BIL's estimates quantile estimates of the genotype coefficients
  tab$lowerStdDev <- tab$Estimate - tab$StdErr # estimate - std err -- calculate lower error bar limit
  tab$upperStdDev <- tab$Estimate + tab$StdErr # estimate + std err -- calculate upper error bar limit
  tab <- tab[with(tab, order(Estimate)), ]
  tab$geno <- factor(tab$geno, levels=tab$geno)
  fdr <- fdrtool(tab$p.value, statistic="pvalue")
  tab$q.value <- fdr$qval
  tab$Significance[tab$q.value > 0.05] <- "non-significant"
  tab$Significance[tab$q.value < 0.05 & tab$q.value > 0.01] <- "q.value_<_0.05"
  tab$Significance[tab$q.value < 0.01 & tab$q.value > 0.001] <- "q.value_<_0.01"
  tab$Significance[tab$q.value < 0.001] <- "q.value_<_0.001"
  tab$Significance[tab$geno=="M82"] <- "M82"
  tab$Significance <- factor(tab$Significance, 
                             levels=c("non-significant", "q.value_<_0.05", "q.value_<_0.01", "q.value_<_0.001", "M82"),
                             labels=c("non-significant", "q.value < 0.05", "q.value < 0.01", "q.value < 0.001", "M82") )
  swooshPlot <- ggplot(tab, aes(y=Estimate, x=geno, ymin=lowerStdDev, ymax=upperStdDev, color=Significance)) + 
    geom_linerange(aes(ymin=lowerCI, ymax=upperCI), alpha=0.5) + geom_pointrange() + theme_bw(16) + 
    theme(axis.text.x = element_text(size=3.5, angle=50, vjust=1, hjust=1)) + labs(x="Genotype", y=comp.y.labs[i]) +
    scale_color_manual(values = c("#de77ae", "#8e0152", "#276419", "#7fbc41", "#4c4c4c") ) # custom color-blind friendly color palette
  ggsave(filename=paste0(names(x)[y], ".pdf"), swooshPlot, width=30, height=15) # use trait column labels to name the preliminary plots
  resultsList <- list(fittedMeans = tab, plot = swooshPlot)
  return(resultsList)
}

# Initialize lists in which to save the ggplot objects and the data.frames with model-fitted means 
comp.plot.list <- vector("list", length=4)
names(comp.plot.list) <- names(comp.rn)[5:8]
comp.df.list <- vector("list", length=4)
names(comp.df.list) <- names(comp.rn)[5:8]
# Vector of Y-axis labels for complexity data
comp.y.labs <- c("Leaf complexity, primary (leaflet counts)", "Leaf complexity, intercalary (leaflet counts)",
                 "Leaf complexity, secondary (leaflet counts)", "Leaf complexity, all (leaflet counts)" )

# place these inside the foreach loop
comp.plot.list[i] <- swooshPlot
comp.df.list[i] <- tab

# Add list element names before saving
save(comp.plot.list, file="comp.plot.list.Rdata")
save(comp.df.list, file="comp.df.list.Rdata")

# Convert the model-fitted mean estimation below into a function to reuse for all traits (w/ the same expt. design)
# The same goes for predicted responses excluding random effects, i.e. convert to a function
#     The prediction function will need 2 variants, i.e. a 2nd one where the model is different (b/c of leaflets, etc) and the pseudo-replicates are averaged

predResp

predRespAvg

FitMeanPseudoRep


# ** should I mess w/ testing each random effect term??  ...and only keeping the significant ones
#----
# form_noPlant <- as.formula( paste0( get("resp"), " ~ FinBIL + (1|block)" ) )
# fit_noPlant <- lmer(form_noPlant, data=x, REML=TRUE)
# 
# form_noBlock <- as.formula( paste0( get("resp"), " ~ FinBIL + (1|plant)" ) )
# fit_noBlock <- lmer(form_noBlock, data=x, REML=TRUE)
# 
# anova(fit, fit_noPlant)
# 
# anova(fit, fit_noBlock)
#----

all.x <- lmer(all ~ FinBIL + (1|block) + (1|plant), comp.rn, REML=T)
all.x  
fixef(all.x)

class(coeftab(all.x))
ct <- as.data.frame(coeftab(all.x))
summary(ct)
head(ct)
rownames(ct)[1] <- "M82"
head(ct)
ct$geno <- rownames(ct)
ct$geno[2:nrow(ct)] <- substr(ct$geno[2:nrow(ct)],7,13)
ct$geno
head(ct)
# convert from coefficient table to model-fitted mean table

ct[2:nrow(ct),1] <- ct[2:nrow(ct),1] + ct[1,1] # i.e. add the intercept estimate to the genotype coefficients' estimates 
ct[2:nrow(ct),3:6] <- ct[2:nrow(ct),3:6] + ct[1,1] # ...and also add the intercept to the quantile estimates of the genotype coefficients
head(ct)
# rename these to more readable names, such as upperStdDev and lowerStdDev
ct$estMse<- ct$Estimate - ct[,2] # estimate - std err -- calculate lower error bar limit
ct$estPse <- ct$Estimate + ct[,2] # estimate + std err -- calculate upper error bar limit
head(ct)
#ct[,1:6] <- as.numeric(ct[,1:6])
class(ct$estPse)
class(ct)
names(ct)[2] <- 'stderr'
summary(ct)
ct <- ct[with(ct, order(Estimate)), ]
head(ct)
ctp <- ct
ctp$geno <- factor(ctp$geno, levels=ctp$geno)
# Plot the whole distribution of predicted genotype effects on "all" complexity counts
ggplot(ctp, aes(y=Estimate, x=geno, ymin=Estimate - stderr, ymax=Estimate + stderr)) + geom_pointrange() + theme_bw() +
  theme(axis.text.x = element_text(size=3.5, angle=50, vjust=1, hjust=1))

head(ct)
head(comp.rn)
summary(comp.rn)
ctall <- ct
ctall$type <- 'all'
head(ctall)
#save(ctall, file="/Users/Dani/UCD/BILs/leaf_traits/ctall.Rdata")
```

## Primary complexity

mpri <- lmer(pri ~ FinBIL + (1|block) + (1|plant), comp.rn, REML=F)
ctpri <- as.data.frame(coeftab(mpri))

summary(ctpri)
head(ctpri)
rownames(ctpri)[1] <- "M82"
head(ctpri)
ctpri$geno <- rownames(ctpri)
ctpri$geno[2:nrow(ctpri)] <- substr(ctpri$geno[2:nrow(ctpri)],7,13)
ctpri$geno
head(ctpri)
# convert from coefficient table to "prediction" table

ctpri[2:nrow(ctpri),1] <- ctpri[2:nrow(ctpri),1] + ctpri[1,1]
ctpri[2:nrow(ctpri),3:6] <- ctpri[2:nrow(ctpri),3:6] + ctpri[1,1]
head(ctpri)
ctpri$estPse <- ctpri$Estimate + ctpri[,2] # estimate + std err
ctpri$estMse<- ctpri$Estimate - ctpri[,2] # estimate - std err 
head(ctpri)
#ctpri[,1:6] <- as.numeric(ctpri[,1:6])
class(ctpri$estPse)
class(ctpri)
names(ctpri)[2] <- 'Std._Error'
summary(ctpri)
ctpri <- ctpri[with(ctpri, order(Estimate)), ]
head(ctpri)
ctpri$type <- 'primary'

ctp <- ctpri
ctp$geno <- factor(ctp$geno, levels=ctp$geno)
# Plot the whole distribution of predicted genotype effects on "all" complexity counts
ggplot(ctp, aes(y=Estimate, x=geno, ymin=Estimate - Std._Error, ymax=Estimate + Std._Error)) + geom_pointrange() + theme_bw() +
  theme(axis.text.x = element_text(size=3.5, angle=50, vjust=1, hjust=1))


## Intercallary complexity

mint <- lmer(int ~ FinBIL + (1|block) (1|plant), comp.rn, REML=F)
ctint <- as.data.frame(coeftab(mint))

summary(ctint)
head(ctint)
rownames(ctint)[1] <- "M82"
head(ctint)
ctint$geno <- rownames(ctint)
ctint$geno[2:nrow(ctint)] <- substr(ctint$geno[2:nrow(ctint)],7,13)
ctint$geno
head(ctint)
# convert from coefficient table to "prediction" table

ctint[2:nrow(ctint),1] <- ctint[2:nrow(ctint),1] + ctint[1,1]
ctint[2:nrow(ctint),3:6] <- ctint[2:nrow(ctint),3:6] + ctint[1,1]
head(ctint)
ctint$estPse <- ctint$Estimate + ctint[,2] # estimate + std err
ctint$estMse<- ctint$Estimate - ctint[,2] # estimate - std err 
head(ctint)
#ctint[,1:6] <- as.numeric(ctint[,1:6])
class(ctint$estPse)
class(ctint)
names(ctint)[2] <- 'Std._Error'
summary(ctint)
ctint <- ctint[with(ctint, order(Estimate)), ]
head(ctint)
ctint$type <- 'intercallary'

ctp <- ctint
ctp$geno <- factor(ctp$geno, levels=ctp$geno)
# Plot the whole distribution of predicted genotype effects on "all" complexity counts
ggplot(ctp, aes(y=Estimate, x=geno, ymin=Estimate - Std._Error, ymax=Estimate + Std._Error)) + geom_pointrange() + theme_bw() +
  theme(axis.text.x = element_text(size=3.5, angle=50, vjust=1, hjust=1))


## Secondary complexity


msec <- lmer(sec ~ FinBIL + (1|block) + (1|plant), comp.rn, REML=F)
ctsec <- as.data.frame(coeftab(msec))

summary(ctsec)
head(ctsec)
rownames(ctsec)[1] <- "M82"
head(ctsec)
ctsec$geno <- rownames(ctsec)
ctsec$geno[2:nrow(ctsec)] <- substr(ctsec$geno[2:nrow(ctsec)],7,13)
ctsec$geno
head(ctsec)
# convert from coefficient table to "prediction" table

ctsec[2:nrow(ctsec),1] <- ctsec[2:nrow(ctsec),1] + ctsec[1,1]
ctsec[2:nrow(ctsec),3:6] <- ctsec[2:nrow(ctsec),3:6] + ctsec[1,1]
head(ctsec)
ctsec$estPse <- ctsec$Estimate + ctsec[,2] # estimate + std err
ctsec$estMse<- ctsec$Estimate - ctsec[,2] # estimate - std err 
head(ctsec)
#ctsec[,1:6] <- as.numeric(ctsec[,1:6])
class(ctsec$estPse)
class(ctsec)
names(ctsec)[2] <- 'Std._Error'
summary(ctsec)
ctsec <- ctsec[with(ctsec, order(Estimate)), ]
head(ctsec)
ctsec$type <- 'secondary'
dim(ctsec)

ctp <- ctsec
ctp$geno <- factor(ctp$geno, levels=ctp$geno)
# Plot the whole distribution of predicted genotype effects on "all" complexity counts
ggplot(ctp, aes(y=Estimate, x=geno, ymin=Estimate - Std._Error, ymax=Estimate + Std._Error)) + geom_pointrange() + theme_bw() +
  theme(axis.text.x = element_text(size=3.5, angle=50, vjust=1, hjust=1))



## NOTE: in this code chunk I'm joining together the parts of the data that will make up the data matrix for clustering
## 
library(plyr)
library(reshape2)
cEst <- join_all(list(ctpri[,c(1,7,10)], ctint[,c(1,7,10)], ctsec[,c(1,7,10)], ctall[,c(1,7,10)]), by=c('geno','type') , type='full')
cEst 
#summary(cEst)
cEst$geno <- as.factor(cEst$geno)
cEst$type <- as.factor(cEst$type)
summary(cEst)
rownames(cEst) <- paste0(cEst$geno,"_",cEst$type)
head(cEst)
tail(cEst)
dim(cEst)
cEst$ID <- rownames(cEst)



ce.noM82 <- cEst[cEst$geno!="M82",]
dim(ce.noM82)
head(ce.noM82)
ceo <- arrange(ce.noM82, geno, type)
head(ceo)
unique(ceo$geno)

cldat <- data.frame(primary=ceo[ceo$type=="primary",1], intercallary=ceo[ceo$type=="intercallary",1], secondary=ceo[ceo$type=="secondary",1], all=ceo[ceo$type=="all",1])
head(cldat)
rownames(cldat) <- unique(ceo$geno)
head(cldat)


## For SparseNet mapping I should use the predicted values ignoring random effects